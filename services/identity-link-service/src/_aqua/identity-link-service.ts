/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.1-231
 *
 */
import { Fluence, FluencePeer } from '@fluencelabs/fluence';
import {
  ResultCodes,
  RequestFlow,
  RequestFlowBuilder,
  CallParams,
} from '@fluencelabs/fluence/dist/internal/compilerSupport/v1';

function missingFields(obj: any, fields: string[]): string[] {
  return fields.filter(f => !(f in obj));
}

// Services

export interface IdentityLinkRouterDef {
  register: (
    payload: string,
    signature: string,
    callParams: CallParams<'payload' | 'signature'>
  ) => { code: number; error: string };
}

export function registerIdentityLinkRouter(
  serviceId: string,
  service: IdentityLinkRouterDef
): void;
export function registerIdentityLinkRouter(
  peer: FluencePeer,
  serviceId: string,
  service: IdentityLinkRouterDef
): void;
export function registerIdentityLinkRouter(...args: any) {
  let peer: FluencePeer;
  let serviceId: any;
  let service: any;
  if (FluencePeer.isInstance(args[0])) {
    peer = args[0];
  } else {
    peer = Fluence.getPeer();
  }

  if (typeof args[0] === 'string') {
    serviceId = args[0];
  } else if (typeof args[1] === 'string') {
    serviceId = args[1];
  }

  // Figuring out which overload is the service.
  // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
  // If the first argument is peer, we are checking further. The second argument might either be
  // an object, that it must be the service object
  // or a string, which is the service id. In that case the service is the third argument
  if (!FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {
    service = args[0];
  } else if (typeof args[1] === 'object') {
    service = args[1];
  } else {
    service = args[2];
  }

  const incorrectServiceDefinitions = missingFields(service, ['register']);
  if (incorrectServiceDefinitions.length) {
    throw new Error(
      'Error registering service IdentityLinkRouter: missing functions: ' +
        incorrectServiceDefinitions.map(d => "'" + d + "'").join(', ')
    );
  }

  peer.internals.callServiceHandler.use((req, resp, next) => {
    if (req.serviceId !== serviceId) {
      next();
      return;
    }

    if (req.fnName === 'register') {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          payload: req.tetraplets[0],
          signature: req.tetraplets[1],
        },
      };
      resp.retCode = ResultCodes.success;
      resp.result = service.register(req.args[0], req.args[1], callParams);
    }

    next();
  });
}

export interface IdentityLinkServiceDef {
  githubRequest: (
    req: { did: string; username: string },
    callParams: CallParams<'req'>
  ) => { code: number; data: { challengeCode: string }; error: string };
  githubVerify: (
    req: { did: string; username: string },
    callParams: CallParams<'req'>
  ) => { code: number; data: { attestation: string } };
}

export function registerIdentityLinkService(
  service: IdentityLinkServiceDef
): void;
export function registerIdentityLinkService(
  serviceId: string,
  service: IdentityLinkServiceDef
): void;
export function registerIdentityLinkService(
  peer: FluencePeer,
  service: IdentityLinkServiceDef
): void;
export function registerIdentityLinkService(
  peer: FluencePeer,
  serviceId: string,
  service: IdentityLinkServiceDef
): void;
export function registerIdentityLinkService(...args: any) {
  let peer: FluencePeer;
  let serviceId: any;
  let service: any;
  if (FluencePeer.isInstance(args[0])) {
    peer = args[0];
  } else {
    peer = Fluence.getPeer();
  }

  if (typeof args[0] === 'string') {
    serviceId = args[0];
  } else if (typeof args[1] === 'string') {
    serviceId = args[1];
  } else {
    serviceId = 'identity-link-service';
  }

  // Figuring out which overload is the service.
  // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
  // If the first argument is peer, we are checking further. The second argument might either be
  // an object, that it must be the service object
  // or a string, which is the service id. In that case the service is the third argument
  if (!FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {
    service = args[0];
  } else if (typeof args[1] === 'object') {
    service = args[1];
  } else {
    service = args[2];
  }

  const incorrectServiceDefinitions = missingFields(service, [
    'githubRequest',
    'githubVerify',
  ]);
  if (incorrectServiceDefinitions.length) {
    throw new Error(
      'Error registering service IdentityLinkService: missing functions: ' +
        incorrectServiceDefinitions.map(d => "'" + d + "'").join(', ')
    );
  }

  peer.internals.callServiceHandler.use((req, resp, next) => {
    if (req.serviceId !== serviceId) {
      next();
      return;
    }

    if (req.fnName === 'githubRequest') {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          req: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      resp.result = service.githubRequest(req.args[0], callParams);
    }

    if (req.fnName === 'githubVerify') {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          req: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      resp.result = service.githubVerify(req.args[0], callParams);
    }

    next();
  });
}

// Functions
